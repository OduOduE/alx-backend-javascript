'use strict';

const watchman = require('fb-watchman');
const captureExit = require('capture-exit');

function values(obj) {
  return Object.keys(obj).map(key => obj[key]);
}

/**
 * Constants
 */

/**
 * Singleton that provides a public API for a connection to a watchman instance for 'sane'.
 * It tries to abstract/remove as much of the boilerplate processing as necessary
 * from WatchmanWatchers that use it. In particular, they have no idea whether
 * we're using 'watch-project' or 'watch', what the 'project root' is when
 * we internally use watch-project, whether a connection has been lost
 * and reestablished, etc. Also switched to doing things with promises and known-name
 * methods in WatchmanWatcher, so as much information as possible can be kept in
 * the WatchmanClient, ultimately making this the only object listening directly
 * to watchman.Client, then forwarding appropriately (via the known-name methods) to
 * the relevant WatchmanWatcher(s).
 *
 * Note: WatchmanWatcher also added a 'watchmanPath' option for use with the sane CLI.
 * Because of that, we actually need a map of watchman binary path to WatchmanClient instance.
 * That is set up in getInstance(). Once the WatchmanWatcher has a given client, it doesn't
 * change.
 *
 * @class WatchmanClient
 * @param String watchmanBinaryPath
 * @public
 */

class WatchmanClient {
  constructor(watchmanBinaryPath) {
    captureExit.captureExit();

    // define/clear some local state. The properties will be initialized
    // in _handleClientAndCheck(). This is also called again in _onEnd when
    // trying to reestablish connection to watchman.
    this._clearLocalVars();

    this._watchmanBinaryPath = watchmanBinaryPath;

    this._backoffTimes = this._setupBackoffTimes();

    this._clientListeners = null; // direct listeners from here to watchman.Client.

    // Define a handler for if somehow the Node process gets interrupted. We need to
    // close down the watchman.Client, if we have one.
    captureExit.onExit(() => this._clearLocalVars());
  }

  // Define 'wildmatch' property, which must be available when we call the
  // WatchmanWatcher.createOptions() method.
  get wildmatch() {
    return this._wildmatch;
  }

  /**
   * Called from WatchmanWatcher (or WatchmanClient during reconnect) to create
   * a watcherInfo entry in our _watcherMap and issue a 'subscribe' to the
   * watchman.Client, to be handled here.
   */
  subscribe(watchmanWatcher, root) {
    let subscription;
    let watcherInfo;

    return this._setupClient()
      .then(() => {
        watcherInfo = this._createWatcherInfo(watchmanWatcher);
        subscription = watcherInfo.subscription;
        return this._watch(subscription, root);
      })
      .then(() => this._clock(subscription))
      .then(() => this._subscribe(subscription));
    // Note: callers are responsible for noting any subscription failure.
  }

  /**
   * Remove the information about a specific WatchmanWatcher.
   * Once done, if no watchers are left, clear the local vars,
   * which will end the connection to the watchman.Client, too.
   */
  closeWatcher(watchmanWatcher) {
    let watcherInfos = values(this._watcherMap);
    let numWatchers = watcherInfos.length;

    if (numWatchers > 0) {
      let watcherInfo;

      for (let info of watcherInfos) {
        if (info.watchmanWatcher === watchmanWatcher) {
          watcherInfo = info;
          break;
        }
      }

      if (watcherInfo) {
        delete this._watcherMap[watcherInfo.subscription];

        numWatchers--;

        if (numWatchers === 0) {
          this._clearLocalVars(); // nobody watching, so shut the watchman.Client down.
        }
      }
    }
  }

  /**
   * Simple backoff-time iterator. next() returns times in ms.
   * When it's at the last value, it stays there until reset()
   * is called.
   */
  _setupBackoffTimes() {
    return {
      _times: [0, 1000, 5000, 10000, 60000],

      _next: 0,

      next() {
        let val = this._times[this._next];
        if (this._next < this._times.length - 1) {
          this._next++;
        }
        return val;
      },

      reset() {
        this._next = 0;
      },
    };
  }

  /**
   * Set up the connection to the watchman client. Return a promise
   * that is fulfilled when we have a client that has finished the
   * capabilityCheck.
   */
  _setupClient() {
    if (!this._clientPromise) {
      this._clientPromise = new Promise((resolve, reject) => {
        this._handleClientAndCheck(resolve, reject);
      });
    }

    return this._clientPromise;
  }

  /**
   * Handle the process of creating a client and doing a capability check and
   * getting a valid response, then setting up local data based on that.
   *
   * This is split from _setupClient and _createClientAndCheck so it can
   * provide the backoff handling needed during attempts to reconnect.
   */
  _handleClientAndCheck(resolve, reject) {
    this._createClientAndCheck().then(
      value => {
        let resp = value.resp;
        let client = value.client;

        try {
          this._wildmatch = resp.capabilities.wildmatch;
          this._relative_root = resp.capabilities.relative_root;
          this._client = client;

          client.on('subscription', this._onSubscription.bind(this));
          client.on('error', this._onError.bind(this));
          client.on('end', this._onEnd.bind(this));

          this._backoffTimes.reset();
          resolve(this);
        } catch (error) {
          // somehow, even though we supposedly got a valid value back, it's
          // malformed, or some other internal error occurred. Reject so
          // the promise itself doesn't hang forever.
          reject(error);
        }